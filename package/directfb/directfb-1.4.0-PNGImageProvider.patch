diff -rupN directfb-1.4.0.orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c directfb-1.4.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c
--- directfb-1.4.0.orig/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c	2009-06-02 18:47:23.000000000 +0200
+++ directfb-1.4.0/interfaces/IDirectFBImageProvider/idirectfbimageprovider_png.c	2013-04-30 12:16:38.009256668 +0200
@@ -204,7 +204,7 @@ Construct( IDirectFBImageProvider *thiz,
      if (!data->png_ptr)
           goto error;
 
-     if (setjmp( data->png_ptr->jmpbuf )) {
+     if (setjmp( png_jmpbuf(data->png_ptr) )) {
           D_ERROR( "ImageProvider/PNG: Error reading header!\n" );
           goto error;
      }
@@ -332,7 +332,7 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
           rect = dst_data->area.wanted;
      }
 
-     if (setjmp( data->png_ptr->jmpbuf )) {
+     if (setjmp( png_jmpbuf(data->png_ptr) )) {
           D_ERROR( "ImageProvider/PNG: Error during decoding!\n" );
 
           if (data->stage < STAGE_IMAGE)
@@ -367,13 +367,15 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
      else {
           CoreSurfaceBufferLock lock;
 
+          int bit_depth = bit_depth = png_get_bit_depth(data->png_ptr,data->info_ptr);
+
           ret = dfb_surface_lock_buffer( dst_surface, CSBR_BACK, CSAID_CPU, CSAF_WRITE, &lock );
           if (ret)
                return ret;
 
           switch (data->color_type) {
                case PNG_COLOR_TYPE_PALETTE:
-                    if (dst_surface->config.format == DSPF_LUT8 && data->info_ptr->bit_depth == 8) {
+                   if (dst_surface->config.format == DSPF_LUT8 && bit_depth == 8) {
                          /*
                           * Special indexed PNG to LUT8 loading.
                           */
@@ -416,7 +418,7 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
                     }
                     else {
                          if (data->color_type == PNG_COLOR_TYPE_GRAY) {
-                              int num = 1 << data->info_ptr->bit_depth;
+                              int num = 1 << bit_depth;
 
                               for (x=0; x<num; x++) {
                                    int value = x * 255 / (num - 1);
@@ -425,7 +427,7 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
                               }
                          }
 
-                         switch (data->info_ptr->bit_depth) {
+                         switch (bit_depth) {
                               case 8:
                                    for (y=0; y<data->height; y++) {
                                         u8  *S = data->image + data->pitch * y;
@@ -480,7 +482,7 @@ IDirectFBImageProvider_PNG_RenderTo( IDi
 
                               default:
                                    D_ERROR( "ImageProvider/PNG: Unsupported indexed bit depth %d!\n",
-                                            data->info_ptr->bit_depth );
+                                            bit_depth );
                          }
 
                          dfb_scale_linear_32( image_argb, data->width, data->height,
@@ -632,6 +634,10 @@ png_info_callback( png_structp png_read_
      int                              i;
      IDirectFBImageProvider_PNG_data *data;
 
+     u32 bpp1[2] = {0, 0xff};
+     u32 bpp2[4] = {0, 0x55, 0xaa, 0xff};
+     u32 bpp4[16] = {0, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff};
+
      data = png_get_progressive_ptr( png_read_ptr );
 
      /* error stage? */
@@ -642,7 +648,7 @@ png_info_callback( png_structp png_read_
      data->stage = STAGE_INFO;
 
      png_get_IHDR( data->png_ptr, data->info_ptr,
-                   &data->width, &data->height, &data->bpp, &data->color_type,
+                   (png_uint_32 *)&data->width, (png_uint_32 *)&data->height, &data->bpp, &data->color_type,
                    NULL, NULL, NULL );
 
      if (png_get_valid( data->png_ptr, data->info_ptr, PNG_INFO_tRNS )) {
@@ -650,50 +656,142 @@ png_info_callback( png_structp png_read_
 
           /* generate color key based on palette... */
           if (data->color_type == PNG_COLOR_TYPE_PALETTE) {
-               u32        key;
-               png_colorp palette    = data->info_ptr->palette;
-               png_bytep  trans      = data->info_ptr->trans;
-               int        num_colors = MIN( MAXCOLORMAPSIZE,
-                                            data->info_ptr->num_palette );
-               u8         cmap[3][num_colors];
-
-               for (i=0; i<num_colors; i++) {
-                    cmap[0][i] = palette[i].red;
-                    cmap[1][i] = palette[i].green;
-                    cmap[2][i] = palette[i].blue;
+               u32            key;
+               png_colorp     palette;
+               png_bytep      trans_alpha;
+               png_color_16p  trans_color;
+               u8             cmap[3][MAXCOLORMAPSIZE];
+               int            num_palette = 0, num_colors = 0, num_trans = 0;
+
+               D_DEBUG_AT(imageProviderPNG,"%s(%d) - num_trans %d \n",__FUNCTION__,__LINE__, num_trans);
+
+               if (png_get_PLTE(data->png_ptr,data->info_ptr,&palette,&num_palette)) {
+
+                   if (png_get_tRNS(data->png_ptr,data->info_ptr,
+                                     &trans_alpha,&num_trans,&trans_color)) {
+                       num_colors = MIN( MAXCOLORMAPSIZE,num_palette );
+
+                       for (i=0; i<num_colors; i++) {
+                         cmap[0][i] = palette[i].red;
+                         cmap[1][i] = palette[i].green;
+                         cmap[2][i] = palette[i].blue;
                }
 
-               key = FindColorKey( num_colors, &cmap[0][0] );
+                       key = FindColorKey( num_colors, &cmap[0][0] );
 
-               for (i=0; i<data->info_ptr->num_trans; i++) {
-                    if (!trans[i]) {
-                         palette[i].red   = (key & 0xff0000) >> 16;
-                         palette[i].green = (key & 0x00ff00) >>  8;
-                         palette[i].blue  = (key & 0x0000ff);
-                    }
+                       for (i=0; i< num_trans; i++) {
+                           if (!trans_alpha[i]) {
+                               palette[i].red   = (key & 0xff0000) >> 16;
+                               palette[i].green = (key & 0x00ff00) >>  8;
+                               palette[i].blue  = (key & 0x0000ff);
+                           }
+                       }
+
+                       data->color_key = key;
+                   }
                }
 
-               data->color_key = key;
+          }
+          else if (data->color_type == PNG_COLOR_TYPE_GRAY) {
+               /* ...or based on trans gray value */
+               png_bytep     trans_alpha;
+               png_color_16p trans_color;
+               int            num_trans = 0;
+
+
+               D_DEBUG_AT(imageProviderPNG,"%s(%d)\n",__FUNCTION__,__LINE__);
+
+               if (png_get_tRNS(data->png_ptr,data->info_ptr,
+                                &trans_alpha,&num_trans,&trans_color) ) {
+                   switch(data->bpp) {
+                       case 1:
+                           data->color_key = (((bpp1[trans_color[0].gray]) << 16) |
+                                              ((bpp1[trans_color[0].gray]) << 8) |
+                                              ((bpp1[trans_color[0].gray])));
+                           break;
+                       case 2:
+                           data->color_key = (((bpp2[trans_color[0].gray]) << 16) |
+                                              ((bpp2[trans_color[0].gray]) << 8) |
+                                              ((bpp2[trans_color[0].gray])));
+                           break;
+                       case 4:
+                           data->color_key = (((bpp4[trans_color[0].gray]) << 16) |
+                                              ((bpp4[trans_color[0].gray]) << 8) |
+                                              ((bpp4[trans_color[0].gray])));
+                           break;
+                       case 8:
+                           data->color_key = (((trans_color[0].gray & 0x00ff) << 16) |
+                                              ((trans_color[0].gray & 0x00ff) << 8) |
+                                              ((trans_color[0].gray & 0x00ff)));
+                           break;
+                       case 16:
+                       default:
+                           data->color_key = (((trans_color[0].gray & 0xff00) << 8) |
+                                              ((trans_color[0].gray & 0xff00)) |
+                                              ((trans_color[0].gray & 0xff00) >> 8));
+                           break;
+                   }
+               }
           }
           else {
                /* ...or based on trans rgb value */
-               png_color_16p trans = &data->info_ptr->trans_values;
-
-               data->color_key = (((trans->red & 0xff00) << 8) |
-                                  ((trans->green & 0xff00)) |
-                                  ((trans->blue & 0xff00) >> 8));
+               png_bytep     trans_alpha;
+               png_color_16p trans_color;
+               int            num_trans = 0;
+
+               D_DEBUG_AT(imageProviderPNG,"%s(%d)\n",__FUNCTION__,__LINE__);
+
+               if (png_get_tRNS(data->png_ptr,data->info_ptr,
+                                &trans_alpha,&num_trans,&trans_color)) {
+                   switch(data->bpp) {
+                       case 1:
+                           data->color_key = (((bpp1[trans_color[0].red]) << 16) |
+                                              ((bpp1[trans_color[0].green]) << 8) |
+                                              ((bpp1[trans_color[0].blue])));
+                           break;
+                       case 2:
+                           data->color_key = (((bpp2[trans_color[0].red]) << 16) |
+                                              ((bpp2[trans_color[0].green]) << 8) |
+                                              ((bpp2[trans_color[0].blue])));
+                           break;
+                       case 4:
+                           data->color_key = (((bpp4[trans_color[0].red]) << 16) |
+                                              ((bpp4[trans_color[0].green]) << 8) |
+                                              ((bpp4[trans_color[0].blue])));
+                           break;
+                       case 8:
+                           data->color_key = (((trans_color[0].red & 0x00ff) << 16) |
+                                              ((trans_color[0].green & 0x00ff) << 8) |
+                                              ((trans_color[0].blue & 0x00ff)));
+                           break;
+                       case 16:
+                       default:
+                           data->color_key = (((trans_color[0].red & 0xff00) << 8) |
+                                              ((trans_color[0].green & 0xff00)) |
+                                              ((trans_color[0].blue & 0xff00) >> 8));
+                           break;
+                   }
+               }
           }
      }
 
      switch (data->color_type) {
           case PNG_COLOR_TYPE_PALETTE: {
-               png_colorp palette    = data->info_ptr->palette;
-               png_bytep  trans      = data->info_ptr->trans;
-               int        num_trans  = data->info_ptr->num_trans;
-               int        num_colors = MIN( MAXCOLORMAPSIZE, data->info_ptr->num_palette );
+               png_colorp     palette;
+               png_bytep      trans_alpha;
+               png_color_16p  trans_color;
+               int            num_palette = 0, num_colors = 0, num_trans = 0;
+
 
-               for (i=0; i<num_colors; i++) {
-                    data->colors[i].a = (i < num_trans) ? trans[i] : 0xff;
+               png_get_PLTE(data->png_ptr,data->info_ptr,&palette,&num_palette);
+
+               png_get_tRNS(data->png_ptr,data->info_ptr,
+                            &trans_alpha,&num_trans,&trans_color);
+
+               num_colors = MIN( MAXCOLORMAPSIZE, num_palette );
+
+               for (i=0; i < num_colors; i++) {
+                    data->colors[i].a = (i < num_trans) ? trans_alpha[i] : 0xff;
                     data->colors[i].r = palette[i].red;
                     data->colors[i].g = palette[i].green;
                     data->colors[i].b = palette[i].blue;
@@ -709,22 +807,21 @@ png_info_callback( png_structp png_read_
           }
 
           case PNG_COLOR_TYPE_GRAY:
-               data->pitch = data->width;
-
-               if (data->bpp == 16)
-                    png_set_strip_16( data->png_ptr );
-
-               break;
+               if (data->bpp < 16) {
+                    data->pitch = data->width;
+                    break;
+               }
 
+               /* fall through */
           case PNG_COLOR_TYPE_GRAY_ALPHA:
                png_set_gray_to_rgb( data->png_ptr );
-               /* fall through */
 
+               /* fall through */
           default:
                data->pitch = data->width * 4;
 
-               if (data->bpp == 16)
-                    png_set_strip_16( data->png_ptr );
+               if (!data->color_keyed)
+                    png_set_strip_16( data->png_ptr ); /* if it is color keyed we will handle conversion ourselves */
 
 #ifdef WORDS_BIGENDIAN
                if (!(data->color_type & PNG_COLOR_MASK_ALPHA))
